

# *MySQL*的使用

**在windows系统中MySQL是不区分大小写的，但是在Linux系统中只有列名和列别名不区分大小写，其他都是区分大小写的。**

## MySQL的安装

**MySQL官网地址：http://www.mysql.com**

进入官网之后选择适合自己电脑操作系统的MysQL安装包下载。

**C语言中文网详细安装教程：http://c.biancheng.net/view/7135.html**

**自定义安装需要安装的模块**

- Connector/J 8.0.19 (这个是mysql对Java的连接器，使用Java操作MySQL必须下载)
- MySQL Shell 8.0.19（这个是MySQL令牌）
- MySQL Server （MySQL服务器）
- MySQL Workbench（MySQL工作台）

## MySQL数据类型

**在MySQL中数据类型大概可以分钟五种：**

- 数值类型

   MySQL中的整数类型有五种。

  |   类型名称   |      说明      | 存储需求 |
  | :----------: | :------------: | :------: |
  |   TINYINT    |   很小的整数   | 1个字节  |
  |   SMALLINT   |    小的整数    | 2个字节  |
  |  MEDIUMINT   | 中等大小的整数 | 3个字节  |
  | INT(INTEGHR) | 普通大小的整数 | 4个字节  |
  |    BIGINT    |     大整数     | 8个字节  |



- 浮点数/定点数类型

  MySQL中使用浮点数和定点数来表示小数。

  浮点类型和定点类型都可以用`（M，D）`来表示，其中`M`成为i精度，表示总共的位数；`D`称为标度，表示小数的位数i。

  | 类型名称         | 说明               | 存储需求  |
  | ---------------- | ------------------ | --------- |
  | FLOAT            | 单精度浮点数       | 4个字节   |
  | DOBULE           | 双精度浮点数       | 8个字节   |
  | DECIMAL(M,D),DEC | 压缩的“严格”定点数 | M+2个字节 |

  <u>不管是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</u>

- 日期/时间类型

  MySQL中有五种表示日期的数据类型。

  | 类型名称  | 日期格式            | 日期范围                                          | 存储需求 |
  | --------- | ------------------- | ------------------------------------------------- | -------- |
  | YEAR      | YYYY                | 1901~2155                                         | 1个字节  |
  | TIME      | HH:MM:SS            | -838:59:59~838:59:59                              | 3个字节  |
  | DATE      | YYYY-MM-DD          | 1000-01-01~9999-12-3                              | 3个字节  |
  | DATETIME  | YYYY-MM-DD HH:MM:SS | 1980-01-01 00:00:00 ~9999-12-31 23:59:59          | 8个字节  |
  | TIMESTAMP | YYYY-MM-DD HH:MM:SS | 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC | 4个字节  |



- 字符串类型

- 二进制类型

### 不同数据类型的使用

**不同的数据类型都会有属于自己的默认值，我们也可以对不同的数据类型进行默认值设定，从而起到设计表的目的。**



**日期类型 TIMESTAMP：**

- DEFAULT CURRENT_TIMESTAMP:如插入记录时未指定具体时间数据，则会插入当前时间的时间戳。
- NO UPDATE CURRENT_TIMESTAMP:如更新记录时未指定具体的时间数据，则会插入当前时间的时间戳。

## 约束

**在MySQL中，约束是对表中数据的一种约束，可以确保数据库中数据的有效性。**

**需要注意的是，约束条件在字段创建的时候并不是必须的。**



MySQL中主要有支持六种约束，以下六种约束，除了主键约束之外，其他约束都可以都多个。

1. **主键约束（PK）：PRIMARY KEY**

   主键约束是使用最频繁的，在进行表的设计时一般都会要求设计一个主键，主键是唯一的，且不允许有空值。*主键约束的添加有两种方式，一种是在字段数据类型后面加上，另外一种在表创建的最后进行添加* **PRIMARY KEY(字段名)**

   **联合主键：**在设计主键的时候可以输入多个字段名，那么这两个字段就被称为联合主键。需要注意的是如果需要设计联合主键那么在字段声名的时候就不能添加主键约束。

   **主键自增：AUTO_INCREMENT**给字段添加可以使该字段实现自增长。

   字段名 数据类型 AUTO_INCREMENT

   ```MySQL
   alter table t1 change id id int auto_increment;
   Query OK, 0 rows affected (0.06 sec)
   Records: 0  Duplicates: 0  Warnings: 0
   ```

   <font color="#900">想要在修改表时添加主键自增，需要使用change关键字进行添加。</font>

  **设置主键初始值**

  ```
    ALTER TALBE testkey AUTO_INCREMENT=10001;
  ```
  **创建表时设置初始id**
  ```
  create table testkey2(
    id int unsigned not null primary key auto_increment,#设置主键为id类型为int unsigned
    name varchar(20) not null)
    auto_increment = 10001;
  ```

  通过alter命令更改主键的

   *删除表主键约束：*

   **ALTER TABLE table_name**

   **DROP PRIMARY KEY**

   <font color="#900">因为每个表中的主键固定只有一个，所以删除主键约束直接DORP PRIMARY KEY就行了。</font>

   ```mysql
   mysql> create table test(
       -> id int primary key,
       -> name varchar(5),
       -> age int,
       -> id_number varchar(18)
       -> );
   Query OK, 0 rows affected (0.02 sec)

   mysql> desc test;
   +-----------+-------------+------+-----+---------+-------+
   | Field     | Type        | Null | Key | Default | Extra |
   +-----------+-------------+------+-----+---------+-------+
   | id        | int         | NO   | PRI | NULL    |       |
   | name      | varchar(5)  | YES  |     | NULL    |       |
   | age       | int         | YES  |     | NULL    |       |
   | id_number | varchar(18) | YES  |     | NULL    |       |
   +-----------+-------------+------+-----+---------+-------+
   4 rows in set (0.01 sec)

   mysql> alter table test
       -> drop primary key;
   Query OK, 0 rows affected (0.05 sec)
   Records: 0  Duplicates: 0  Warnings: 0

   mysql> desc test;
   +-----------+-------------+------+-----+---------+-------+
   | Field     | Type        | Null | Key | Default | Extra |
   +-----------+-------------+------+-----+---------+-------+
   | id        | int         | NO   |     | NULL    |       |
   | name      | varchar(5)  | YES  |     | NULL    |       |
   | age       | int         | YES  |     | NULL    |       |
   | id_number | varchar(18) | YES  |     | NULL    |       |
   +-----------+-------------+------+-----+---------+-------+
   4 rows in set (0.00 sec)
   mysql> alter table test
       -> add primary key(id);
   Query OK, 0 rows affected (0.04 sec)
   Records: 0  Duplicates: 0  Warnings: 0
   mysql> desc test;
   +-----------+-------------+------+-----+---------+-------+
   | Field     | Type        | Null | Key | Default | Extra |
   +-----------+-------------+------+-----+---------+-------+
   | id        | int         | NO   | PRI | NULL    |       |
   | name      | varchar(5)  | YES  |     | NULL    |       |
   | age       | int         | YES  |     | NULL    |       |
   | id_number | varchar(18) | YES  |     | NULL    |       |
   +-----------+-------------+------+-----+---------+-------+
   4 rows in set (0.00 sec)
   mysql> alter table test
       -> change column id id int auto_increment;
   Query OK, 0 rows affected (0.04 sec)
   Records: 0  Duplicates: 0  Warnings: 0

   mysql> desc test;
   +-----------+-------------+------+-----+---------+----------------+
   | Field     | Type        | Null | Key | Default | Extra          |
   +-----------+-------------+------+-----+---------+----------------+
   | id        | int         | NO   | PRI | NULL    | auto_increment |
   | name      | varchar(5)  | YES  |     | NULL    |                |
   | age       | int         | YES  |     | NULL    |                |
   | id_number | varchar(18) | YES  |     | NULL    |                |
   +-----------+-------------+------+-----+---------+----------------+
   4 rows in set (0.00 sec)
   ```

   <font color="#900">以上操作时在是创建数据库时添加主键约束，之后进行主键约束的删除，添加和添加主键自增。</font>



   ****

2. **外键约束（FK）：FOREIGN KEY**

   外键约束是和主键约束一起使用的，用来保证数据的一致性。可以理解为一个表的外键就是另外一个表的主键，外键可以重复，主键不可以重复。如果一个表的主键是另外一个表的外键，那么这两个表的关联性就会被加强。



   *创建表时设置外键约束：*

   **[CONSTRAINT <外键名>] FOREIGN KEY 字段名[字段名2,...]**

   **REFERENCES <主表名> 主键1[,主键2,...];**

   <font color="#900">**在进行外键的定义时，CONSTRAINT并不是必须的，它存在的意义仅仅只是为了在删除外键时使用，即使不手动添加外键名执行SQL语句也不会报错，数据库在运行SQL语句时会自动添加上默认的外键名，可以通过使用 SHOW CREATE TABLE table_name 展示表结构语句来查看表中外键的默认名**</font>



   *删除表外键约束：*

   **ALTER TABLE table_name DROP FOREIGN KEY 外键约束名**



   *在修改表时添加外键约束：*

   **ALTER TABLE table_name**

   **ADD [CONSTRAINT <外键名>] **

   **FOREIGN KEY 字段名[字段名2,...]**

   **REFERENCES <主表名> 主键[,主键2,...];**

   <font color="#900">我们可以在修改表时创建外键约束，但是有一点需要特别注意，要确保添加外键约束的列的值都来自主表的主键列，且外键列不能为空。</font>





   **定义外键时，需要遵守下列规则：**

   - 主表必须已经存在与 数据库中，或者是当前正在创建的表。如果是第二种情况，则主表与从表是同一个表，这样的表为子参照表，这种结构称为自参照完整性。
   - 进行关联的主表必须有主键。
   - 主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的非空内容与主键的内容一致，则这个外键就是真确的。
   - 在主表的表面那个后面指定列名或列名的组合，这个列或列的组合必须是主表的主键或候选键。
   - 外键中列的数量必须和主表中主键的数目相同。
   - 外键中列的数据类型必须和主表中主键的数据类型一致。

   ```mysql
   mysql> create table test2(
       -> id int,
       -> id_number int,
       -> constraint k
       -> foreign key(id_number)
       -> references test(id)
       -> );
   Query OK, 0 rows affected (0.05 sec)

   mysql> show create table test2;
   +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Table | Create Table                                                                                                                                                                                                                                    |
   +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | test2 | CREATE TABLE `test2` (
     `id` int DEFAULT NULL,
     `id_number` int DEFAULT NULL,
     KEY `k` (`id_number`),
     CONSTRAINT `k` FOREIGN KEY (`id_number`) REFERENCES `test` (`id`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
   +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   1 row in set (0.00 sec)
   mysql> alter table test2
       -> drop foreign key k;
   Query OK, 0 rows affected (0.01 sec)
   Records: 0  Duplicates: 0  Warnings: 0

   mysql> show create table test2;
   +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Table | Create Table                                                                                                                                                               |
   +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | test2 | CREATE TABLE `test2` (
     `id` int DEFAULT NULL,
     `id_number` int DEFAULT NULL,
     KEY `k` (`id_number`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
   +-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   1 row in set (0.00 sec)

   mysql> alter table clerk_position
       -> add constraint clerk_position_clerk
       -> foreign key (id)
       -> references clerk(id);
   Query OK, 0 rows affected (0.07 sec)
   Records: 0  Duplicates: 0  Warnings: 0
   ```

   <font color="#900">这里新创建了一个表，创建了一个外键约束，此表被外键约束的字段是id_number链接的是test表的id。**需要注意的是添加外键约束的时候，只能链接主表的主键。**</font>

   <font color="#900">**在使用外键约束关联了两个表之后，在后续进行修改或者更改表字段的时候需要多多注意。首先是字段的数据类型要一致，且外键的值不能在主表主键值的范围之外。**</font>

   ****

3. **唯一约束：Unique Key**

   唯一约束和主键约束类似，他们都可以确保信息唯一性，但是唯一约束可以为空，且唯一约束可以有多个。



   *创建表时设置唯一约束语法：*

   **<字段名> <数据类型> UNIQUE**



   *在修改表时添加唯一约束语法：*

   **ALTER TABLE <表名> ADD CONSTRAINT <唯一约束名> UNIQUE(<列名>);**



   *删除唯一约束语法：*

   **ALTER TABLE <表名> DORP INDEX <唯一约束名>;**

   <font color="#900">唯一约束的使用场景比较少，只有在表中已有主键且有字段具有唯一性的地方才需要使用，且需要注意的是唯一约束与外键约束不同，唯一约束的默认唯一约束名就是字段本身，在删除唯一约束的时候之哟啊加上**INDEX**关键字就可以删除约束了。</font>



   ```MySQL
   mysql> alter table test
       -> add unique key(id_number);
   Query OK, 0 rows affected (0.05 sec)
   Records: 0  Duplicates: 0  Warnings: 0

   mysql> desc test;
   +-----------+-------------+------+-----+---------+----------------+
   | Field     | Type        | Null | Key | Default | Extra          |
   +-----------+-------------+------+-----+---------+----------------+
   | id        | int         | NO   | PRI | NULL    | auto_increment |
   | name      | varchar(5)  | YES  |     | NULL    |                |
   | age       | int         | YES  |     | NULL    |                |
   | id_number | varchar(18) | YES  | UNI | NULL    |                |
   +-----------+-------------+------+-----+---------+----------------+
   4 rows in set (0.03 sec)
   mysql> show create table test;
   +-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Table | Create Table                                                                                                                                                                                                                                                                                  |
   +-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | test  | CREATE TABLE `test` (
     `id` int NOT NULL AUTO_INCREMENT,
     `name` varchar(5) DEFAULT NULL,
     `age` int DEFAULT NULL,
     `id_number` varchar(18) DEFAULT NULL,
     PRIMARY KEY (`id`),
     UNIQUE KEY `id_number` (`id_number`)
   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
   +-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   1 row in set (0.02 sec)

   mysql> alter table test
       -> drop index id_number;
   Query OK, 0 rows affected (0.05 sec)
   Records: 0  Duplicates: 0  Warnings: 0

   mysql> desc test;
   +-----------+-------------+------+-----+---------+----------------+
   | Field     | Type        | Null | Key | Default | Extra          |
   +-----------+-------------+------+-----+---------+----------------+
   | id        | int         | NO   | PRI | NULL    | auto_increment |
   | name      | varchar(5)  | YES  |     | NULL    |                |
   | age       | int         | YES  |     | NULL    |                |
   | id_number | varchar(18) | YES  |     | NULL    |                |
   +-----------+-------------+------+-----+---------+----------------+
   4 rows in set (0.03 sec)
   ```

   <font color="#900">这里首先是给id_number字段添加了唯一约束，之后查看表结构看到唯一约束名和字段名其实是一致的，最后使用alter删除该字段的唯一约束。**这里需要注意的是删除唯一字段的时候在drop之后使用的关键字是index后面跟唯一字段名。**</font>

   ****

4. **检查约束：CHECK**

   检查约束是用来检查数据表中字段是否有效的手段，可以对数据进行限制，减少无效数据的输入。

   <font color="#900">**若将CHECK约束子语句至于所有列的定义以及主键约束和外键约束定义之后，则种种约束也成为基于表的CHECK约束。该约束可以同时对表中多个列设置限定条件。**</font>



   *创建表时设置检查约束语法：*

   **CHECK<布尔表达式>**



   *在修改表时添加检查约束语法：*

   **ALTER TABLR <table_name> ADD CONSTRAINT <检查约束名> CHECK(<布尔表达式>)**

   <font color="#900">在修改表时添加的检查约束是可以针对表中多个列设置限制条件的。</font>



   *删除检查约束语法：*

   **ALTER TABLE <table_name> DROP CONSTRAINT <检查约束名>；**

   ```MySQL
   mysql> alter table test
       -> add  constraint k
       -> check(age>10);
   Query OK, 1 row affected (0.11 sec)
   Records: 1  Duplicates: 0  Warnings: 0

   mysql> insert into test(name,age,id_numbner) values('lizanyang',1,'223');
   ERROR 1054 (42S22): Unknown column 'id_numbner' in 'field list'
   mysql> insert into test(name,age,id_number) values('lzu',11,'12313');
   Query OK, 1 row affected (0.02 sec)

   mysql> select * from test;
   +----+------+------+-----------+
   | id | name | age  | id_number |
   +----+------+------+-----------+
   |  1 | li   |   18 | 11        |
   |  2 | lzu  |   11 | 12313     |
   +----+------+------+-----------+
   2 rows in set (0.00 sec)
   ```

   <font color="#900"></font>

   ****

5. **非空约束：NOT NULL**

   用来约束表中字段不能为空。



   *创建表时设置非空约束语法：*

   **<字段名> <数据类型> NOT NULL**



   *在修改表时添加非空约束：*

   **ALTER TABLE <表名> CHANGE COLUMN <字段名> <字段名> <数据类型> NUT NULL**

   <font color="#900">**需要注意的是这里在添加表时使用的关键字不是ADD而是CHANGE COLUMN关键字，所以需要注意字段名和数据类型的填入需要和本身的类型一致。**</font>



   *删除表字段非空约束语法：*

   **ALTER TABLE <表名> CHANGE COLUMN <字段名> <字段名> <数据类型> NULL**

   <font color="#900">删除非空约束和在修改表时添加非空约束很相似，也是使用的CHANGE关键字，唯一不同的是将NOT NULL换成NULL就可以删除字段的非空约束了。</font>



   ****

1. **默认值约束：Default Constraint**

   默认值约束可以在输入字段值为空时，自动添加默认的值。

   `默认值约束通常用在已经设置了非空约束的列，这样嫩巩固防止数据表在录入数据的时候出现错误。`

   *在创建表时设置非空约束语法：*

   **<字段名> <数据类型> DEFAULT <默认值>**



   *修改表时添加默认值约束：*

   **ALTER TABLE <表名> CHANGE COLUMN <字段名> <数据类型> DEFAULT <默认值>**



   *删除默认值约束：*

   **ALTER TABLE <表名> CHANGE COLUMN <字段名> <字段名> <数据类型> DEFAULT NULL;**

   <font color="#900">设置默认值约束的方法类似于设置非空约束，使用的都是CHANGE子语句，删除默认值的方法也是将默认值重新设置为NULL的过程。</font>




****



## MySQL运算符优先级

| 优先级 | 运算符                                            |
| ------ | ------------------------------------------------- |
| 1      | =(复制运算)、:=                                   |
| 2      | \|\|,OR                                           |
| 3      | XOR                                               |
| 4      | &&,AND                                            |
| 5      | NOT                                               |
| 6      | BETWEEN,CASE,WHERE,THEN,ELSE                      |
| 7      | =(比较运算),<=>,>=,>,<=,<,<>,!=,IS,LIKE,REGEXP,IN |
| 8      | \|                                                |
| 9      | &                                                 |
| 10     | <<,>>                                             |
| 11     | -(减号),+                                         |
| 12     | *,/,%                                             |
| 13     | ^                                                 |
| 14     | -(负号）、〜（位反转）                            |
| 15     | ！                                                |

****



## MySQL使用命令

**常用指令链接：https://www.cnblogs.com/linjiqin/archive/2013/03/01/2939384.html**

**SQL语句整体被分为四大类：**https://blog.csdn.net/weixin_32262089/article/details/113438567

- DDL（数据定义语言）：

  数据定义语言是用于定义数据库模式的SQL命令，用于创建和修改，删除数据库中的数据对象的结构。

- DML（数据操作语言）：

  数据操作语言是处理数据库中存在的数据的SQL命令。

- DCL（数据控制语言）：

  数据控制语言主要用来处理数据库系统的权限和其他控制。

- TCL（事务控制语言）：

  事务控制语言主要用来处理数据库中的业务，比如提交交易，业务回滚。


****



### MySQL常用指令：

1. **flush privileges：**

   这条指令的意思是立即执行权限的更改，有时候我们在数据库中进行user权限的更改，MySQL默认不会生效，这个时候有两种方法，一种是进行数据库的重启（有时候不管用），或者执行 flush privileges;指令。

2. **desc table_name：**

   这条命令的意思是查看表结构，通过关键字desc+表名可以查看此表的详细信息与结构。

3. **system cls:**

   这条命令可以清空指令。

4. **create database database_name:**

   此指令用于创建数据库。

5. **drop databse:**

   此指令用于删除数据库。

6. **create table table_name(列名 类型):**

   此指令用于拆创建表。

7. **drop table table_name:**

   此指令用于删除表。

8. **use database:**

   此指令用于进入数据库，如果要在数据库中创建新表的话，首先要进入数据库。

#### 操作数据指令

- **INSERT INTO（添加）：**

  **INSERT INTO <table_name> (column1,column2,......) VALAUES (value1,value2,......); **

  在使用添加语句时，需要注意列名和每列对应的值要对应一致，有些自带默认值的可以不进行添加。

  添加指令可以进行简写：

  ```
  INSERT INTO <tablename> VALUES(value1,value2,value3);
  ```

  需要注意的是，这样写需要对应列的顺序。

- **DELETE （删除）：**

  **DELETE FROM <teble_name> WHERE [condition];**

  在使用删除语句的时候需要注意使用WHERE筛选条件，如果不进行指定的话就会删除表中所有的内容。

- **UPDATE SET（修改）：**

  **UPDATE <table_name> SET column1=value1,column1=value1,...... WHERE [condition];**

  在使用修改语句的时候需要注意数据类型的对应，与删除操作一样如果不适用WHERE筛选条件就会修改所有数据。

- **SELECT（查询）：**

  **SELECT column1,column2,...... FROM <table_name> WHERE [condition];**

  在使用查询语句进行查询的时候如果想要查询表内所有的信息，可以使用*代替所有列。

#### WHERE的使用

**我们在使用查询语句进行信息查询的时候，都会用到WHERE关键字，但是只有一个筛选条件很难满足我们大部分需求。**



**多条件查询语句：**我们可以在进行查询的时候使用逻辑运算符进行多条件筛选。

- AND：记录满足所有查询条件时，才会被查询出来。
- OR：记录满足任意一个查询条件时，才会被查询出来。
- XOR：记录满足其中一个条件，并且不满足另外一个条件时，才会被查询出来。

**这些逻辑运算符可以混合起来使用，但是一定要注意运算的优先级。**

****



#### LIKE子语句

**LIKE子语句用于在WHERE语句中进行模糊匹配，会将给定的匹配模式和字段进行比较，匹配成功则选取，否则不选取。他的使用方式类似于正则表达式。**

**子语句可以和通配符一起使用：**

| 通配符                   | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 百分号（%）              | 代表零个，一个或多个任意字符。                               |
| 下划线（_）              | 代表单个字符或者数字。                                       |
| [charlist]               | 字符列表中的任何一个字符。可以使用连接字符(-)根据ASCLL编码指定一个字符范围。[0-9]表示0到9的任意数字。 [a-z]表示小写英文字母 。[a-zA-Z] 表示大小写的英文字母。[a-zA-Z0-9]表示英文字母和阿拉伯数字。 |
| [^charlist]或[!charlist] | 不在字符列表中的任何一的任何单一字符。同上可以使用连字符（-）指定一个字符范围。 |

通过使用模糊匹配可以更加准确的匹配一些内容。

使用模糊查询的语法格式：

```mysql
mysql> select * from mb;/*首先查看表结构*/
+----+--------+
| id | name   |
+----+--------+
|  1 | lzy    |
|  2 | 王     |
|  4 | 张三   |
|  5 | 张三   |
|  7 | wang   |
|  9 | zhang  |
| 10 | zhang  |
+----+--------+
7 rows in set (0.00 sec)
mysql> select * from mb where name like '%a%';
/*这里使用了模糊查询，查询了姓名中带有a的用户*/
+----+-------+
| id | name  |
+----+-------+
|  7 | wang  |
|  9 | zhang |
| 10 | zhang |
+----+-------+
3 rows in set (0.00 sec)
mysql> select * from mb where name not like '%a%';
/*这里是name中不包含a的所有字段*/
+----+--------+
| id | name   |
+----+--------+
|  1 | lzy    |
|  2 | 王     |
|  4 | 张三   |
|  5 | 张三   |
+----+--------+
4 rows in set (0.00 sec)
```

###### **使用通配符的注意事项**

下面是使用通配符的一些注意事项：

- <font color="#f00">**注意大小写**</font>。MySQL 默认是不区分大小写的。如果区分大小写，像“Tom”这样的数据就不能被“t%”所匹配到。
- **注意尾部空格**，尾部空格会干扰通配符的匹配。例如，“T% ”就不能匹配到“Tom”。
- **注意 NULL**。“%”通配符可以到匹配任意字符，但是不能匹配 NULL。也就是说 “%”匹配不到 tb_students_info 数据表中值为 NULL 的记录。


下面是一些使用通配符要记住的技巧。

- 不要过度使用通配符，如果其它操作符能达到相同的目的，应该使用其它操作符。因为 MySQL 对通配符的处理一般会比其他操作符花费更长的时间。
- 在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。
- 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。



****



#### 修改表字段内容指令ALTER

**在我们需要进行表字段信息修改时，就可以使用ALTER TABLE 命令进行修改，修改分为以下几种。**



- **修改字段：ALTER TABLE <表名> MODIFY <字段名> <数据类型> [约束条件]**

  执行这段指令可以修改已经存在的字段内容和约束。

  **CHANGE**关键字也可以用来修改字段，使用方式如下：**ALTER TABLE <表名> CHANGE <旧字段名> <新字段名> [约束条件]**CHANGE关键字的使用需要注意字段名的位置。



- **添加字段：ALTER TABLE <表名> ADD <新字段名> <数据类型> [约束条件]**

  执行这段指令可以在表字段的尾部添加新的字段，因为MySQL默认是在最后添加字段。在开头添加字段需要在最后添加关键字**FIRST**。

  *在表中间添加字段需要使用关键字**AFTER*** **ALTER TABLE <表名> ADD<新字段名> <数据类型> [约束条件] AFTER <已存在的字段名>**执行语句之后就会在旧的字段名之后添加新的字段。



- **修改表名：ALTER TABLE <旧表名> RENAME <新表名>; RENAME TABLE <旧表名> TO <新表名>;**

  以上两种方式都可以进行表名的修改。



- **删除主键约束：ALTER TABLE <表名> DROP PRIMARY KEY;**

  执行这段指令可以删除指定表中的主键约束。



**当我们需要对字段添加约束的时，可以使用修改字段的方式进行添加，也可以使用添加字段的方式进行添加，使用添加字段的方式进行添加约束的语法类似于在拆功能键表的最后一行添加约束。**

****

## SELECT 的进阶使用操作

### 子语句的使用

#### 起别名

##### 为表起别名

在进行表查询的时候，如果表名是很长的一串单词，为了方便操作，可以为表起一个别名，用这个别名代替表原来的名称。

*为表起别名的基本与语法如下：*

**<表名> [AS] <别名>**

其中AS关键字可以省略，省略后需要将表名和别名用空格隔开。

<font color="#900">表的别名不能与该数据库的其他表名同名，字段的别名不能与该表中的其他字段同名。*在条件表达式中不能使用字段别名，否则会出现ERROR 1054 (42S22): Unknown column”这样的错误提示信息。* **在MySQL中给表起名可以带数字，但是在带有数字的表在起别名时会报出”Unknown column 't.name' in 'field list'“错误。**</font>

```MySQL
mysql> select s.name from tt  s;
+------+
| name |
+------+
| li   |
+------+
1 row in set (0.00 sec)
```



****

##### 为字段起别名

在使用SELECT语句查询数据时，MySQL会显示每个SELECT后面指定输出的字段，在进行某些字段运算的时候，查询粗来的临时表字段会显示出字段的运算过程，这个时候就可以通过给表字段起别名来掩盖。

*为表起别名的基本与语法如下：*

**<表名> [AS] <别名>**

其中AS关键字可以省略，省略后需要将表名和别名用空格隔开。

```MySQL
mysql> select s.name n from tt s;
+------+
| n    |
+------+
| li   |
+------+
1 row in set (0.00 sec)
```



****

#### ORDER BY子语句排序

ORDER BY子语句用于根据一个或多个字段对查询结果（结果集）进行排序，在MySQL中默认是升序。

使用语法：**SELECT column_list FROM table_name [WHERE condition] [ORDER BY <column1,column2,......>] [ASC|DESC]**ASC关键字表示升序，DESC表示降序。

在使用ORDER BY子语句进行排序的时候可以添加多个排序字段，他在执行的过程中总是会优先进行第一个字段的排序，当有多个第一字段一样时，才会进行第二字段的排序，以此类推。

```mysql
+----+------+-----+------------+
| id | name | age | id_number  |
+----+------+-----+------------+
|  1 | li   |  18 | 1121233a   |
|  2 | li   |  18 | 112sdafg3a |
|  3 | sa   |  17 | 1          |
|  4 | aa   |  19 | a          |
|  5 | aaa  |  16 | 1a         |
|  6 | li   |  17 | 1s         |
+----+------+-----+------------+
6 rows in set (0.00 sec)

mysql> select * from class order by name,age;
+----+------+-----+------------+
| id | name | age | id_number  |
+----+------+-----+------------+
|  4 | aa   |  19 | a          |
|  5 | aaa  |  16 | 1a         |
|  6 | li   |  17 | 1s         |
|  1 | li   |  18 | 1121233a   |
|  2 | li   |  18 | 112sdafg3a |
|  3 | sa   |  17 | 1          |
+----+------+-----+------------+
6 rows in set (0.00 sec)
```

这里有一个名为class的表，这里使用order by通过姓名和年龄进行排序，可以看到首先比较的是姓名，当姓名相同的时候才会进行年龄的排序。

#### GROUP BY子语句分组

GROUP BY子语句用来根据指定的字段对结果集（选取的数据）进行分组，**GROUP BY关键字后面有几个字段，就表示可以分成几组**。

使用语法：**SELECT column_list FROM table_name [WHERE condition] [GROUP BY < column1,column2 > [HAVING] < coditions >]**



```mysql
+----+------+--------+
| id | name | gender |
+----+------+--------+
|  1 | lzy  | 男     |
|  2 | zz   | 男     |
|  3 | gx   | 男     |
|  4 | gx   | 女     |
|  5 | jr   | 女     |
+----+------+--------+
5 rows in set (0.00 sec)

mysql> select * from student group by gender;
+----+------+--------+
| id | name | gender |
+----+------+--------+
|  1 | lzy  | 男     |
|  4 | gx   | 女     |
+----+------+--------+
2 rows in set (0.00 sec)
```

如上所示，在使用GROUP BY子语句进行分组的时候，如果是单独使用GROUP BY关键字，那么查询结果只会显示每一个分组的第一条记录。

**如果我们在GROUP BY 后边加上多个条件那么他的效果是这样的：**

```mysql
+----+------+--------+
| id | name | gender |
+----+------+--------+
|  1 | lzy  | 男     |
|  2 | zz   | 男     |
|  3 | gx   | 男     |
|  4 | gx   | 女     |
|  5 | jr   | 女     |
|  6 | lzu  | 女     |
|  7 | lzy  | 女     |
|  8 | lzy  | 男     |
+----+------+--------+
mysql> select group_concat(name) as 姓名,group_concat(gender) as 性别 from student group by name,gender;
+---------+---------+
| 姓名    | 性别    |
+---------+---------+
| gx      | 女      |
| gx      | 男      |
| jr      | 女      |
| lzu     | 女      |
| lzy     | 女      |
| lzy,lzy | 男,男   |
| zz      | 男      |
+---------+---------+
7 rows in set (0.00 sec)
```

可以看到，分组查询如果给出多个条件的话，他的运行方式是和排序类似的，会先进行第一个条件的分组，在又多个字段同时满足第一个字段的条件时，才会进行第二条件的分组。

##### GROUP BY 和 GROUP_CONCAT()

GROUP BY 关键字可以和GROUP_CONCAT()函数一起使用。GROUP_CONCAT()函数会把分组的每个字段都显示出来。

```mysql
+----+------+--------+
| id | name | gender |
+----+------+--------+
|  1 | lzy  | 男     |
|  2 | zz   | 男     |
|  3 | gx   | 男     |
|  4 | gx   | 女     |
|  5 | jr   | 女     |
+----+------+--------+
5 rows in set (0.00 sec)

mysql> select group_concat(name) from student group by gender;
+--------------------+
| group_concat(name) |
+--------------------+
| gx,jr              |
| lzy,zz,gx          |
+--------------------+
2 rows in set (0.00 sec)

mysql> select gender,group_concat(name) from student group by gender;
+--------+--------------------+
| gender | group_concat(name) |
+--------+--------------------+
| 女     | gx,jr              |
| 男     | lzy,zz,gx          |
+--------+--------------------+
2 rows in set (0.00 sec)
```

****

##### GROUP BY 与聚合函数

**在进行统计的时候，我们经常使用聚合函数和GROUP BY关键字一起使用**

| 函数名称 | 作用                             |
| -------- | -------------------------------- |
| MAX      | 查询指定列的最大值。             |
| MIN      | 查询指定列的最小值               |
| COUNT    | 统计查询结果的行数               |
| SUM      | 求和，返回指定列的总和           |
| AVG      | 求平均值，返回指定列数据的平均值 |

这里需要注意的点有聚合函数的运行特点，如果不注意的话就会导致得到的结果与我们想要结果出现偏差。

**所有聚合函数都会忽略字段值为空(NULL)的行COUNT函数有两种情况，在使用COUNT(column)对特定进行技术的时候，会忽略NULL值，在使用CONUNT(*)对表中行目进行计数时，不管字段中数值是什么都会计入总数。**

****

##### HAVING筛选

HAVING关键字类似与WHERE，他是针对于GROUP BY的条件筛选关键字。通过HAVING关键字我们可以在需要分组的所有字段中进行筛选，从而获得我们所需要字段的分组；

```mysql
+----+------+------+
| id | age  | name |
+----+------+------+
|  1 |    1 | NULL |
|  2 |    2 | NULL |
|  3 |    2 | NULL |
|  4 |    3 | NULL |
|  5 | NULL | lzy  |
+----+------+------+
5 rows in set (0.05 sec)

mysql> select age,group_concat(id) as id from test group by age having age=2;
+------+------+
| age  | id   |
+------+------+
|    2 | 2,3  |
+------+------+
1 row in set (0.00 sec)
```

上面代码在进行分组查询test表时使用了HAVING筛选出所有age为2的的id信息。

#### 连接查询

**在关系型数据库中，表于表之间是有联系的，所以在实际应用的过程中经常使用多表查询。多表查询就是同时查询两个或两个以上的表。**

- 连接查询是指基于两个或两个以上的基本表或视图的查询。

- 连接方式主要有：内连接，外连接和完全连接。

- 连接查询的语法规则：**SELECT cloumn1,column2**

  **FROM table1 [INNER|LEFT|RIGHT|FULL|CROSS] JOIN table2**

  **NO condition(column1=column2) [WHERE condition] **

  ****

##### 交叉连接（CROSS JOIN）：

<font color="#900">**交叉连接又叫”笛卡尔积“它是指不适用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。**</font>

交叉连接一般用来返回连接表的笛卡尔积。

*交叉连接的使用语法如下：*

**SELECT <表名> FORM <表1> CROSS JOIN <表2> [WHERE字句]**

**或SELECT <字段名> FROM <表1>,<表2> [WHERE子语句]**

**语法说明为下：**

- 字段名：需要查询的字段名称。
- <表1> <表2>：需要交叉连接的表名。
- WHERE子语句：用来设置交叉连接的查询条件。

<font color="#900">需要多个表交叉连接时，在FROM后连续使用CROSS JOIN或`，`即可。以上两种方法使用方法返回的结果都是相同的，但是第一种语法才是官方建议的标准写法。</font>

```MySQL
mysql> select * from t1 cross join t2;
+----+-------+------+----+---------+-----------+
| id | name  | age  | id | address | id_number |
+----+-------+------+----+---------+-----------+
|  3 | wang  |   18 |  1 | 陕西    | 123123123 |
|  2 | zhang |   18 |  1 | 陕西    | 123123123 |
|  1 | li    |   18 |  1 | 陕西    | 123123123 |
|  3 | wang  |   18 |  2 | 江西    | 123123123 |
|  2 | zhang |   18 |  2 | 江西    | 123123123 |
|  1 | li    |   18 |  2 | 江西    | 123123123 |
|  3 | wang  |   18 |  3 | 云南    | 123123123 |
|  2 | zhang |   18 |  3 | 云南    | 123123123 |
|  1 | li    |   18 |  3 | 云南    | 123123123 |
+----+-------+------+----+---------+-----------+
9 rows in set (0.00 sec)

mysql> select * from t1,t2;
+----+-------+------+----+---------+-----------+
| id | name  | age  | id | address | id_number |
+----+-------+------+----+---------+-----------+
|  3 | wang  |   18 |  1 | 陕西    | 123123123 |
|  2 | zhang |   18 |  1 | 陕西    | 123123123 |
|  1 | li    |   18 |  1 | 陕西    | 123123123 |
|  3 | wang  |   18 |  2 | 江西    | 123123123 |
|  2 | zhang |   18 |  2 | 江西    | 123123123 |
|  1 | li    |   18 |  2 | 江西    | 123123123 |
|  3 | wang  |   18 |  3 | 云南    | 123123123 |
|  2 | zhang |   18 |  3 | 云南    | 123123123 |
|  1 | li    |   18 |  3 | 云南    | 123123123 |
+----+-------+------+----+---------+-----------+
9 rows in set (0.00 sec)
```

<font color="#900">**使用交叉查询会查询出两个表的笛卡尔积所以在进行数据较多表之间的连接时，会产出很多我们不需要的多余数据，我们可以使用WHERE子语句进行数据的筛选。**</font>

```MySQL
mysql> select * from t1 cross join t2 where t1.id=t2.id;
+----+-------+------+----+---------+-----------+
| id | name  | age  | id | address | id_number |
+----+-------+------+----+---------+-----------+
|  1 | li    |   18 |  1 | 陕西    | 123123123 |
|  2 | zhang |   18 |  2 | 江西    | 123123123 |
|  3 | wang  |   18 |  3 | 云南    | 123123123 |
+----+-------+------+----+---------+-----------+
3 rows in set (0.00 sec)
```

<font color="#900">**需要注意的是，在使用CROSS JOIN交叉连接中使用WHERE子语句时，MySQL会先生成两个表的笛卡尔积，然后再选择满足WHERE条件的记录，因此，在表数量角度时，交叉连接会非常缓慢。**</font>



****

###### 笛卡尔积

**笛卡尔积(Cartesian product)是指两个或多个集合的乘积。**

例如现在有两个集合A和B他们的值如下：

`A={1,2},B={1,2,3}`

集合A×B和B×A的结果集分别表示为

`A×B={(1,3), (1,4), (1,5), (2,3), (2,4), (2,5) };`
`B×A={(3,1), (3,2), (4,1), (4,2), (5,1), (5,2) };`

以上A×B和B×A的结果就叫做两个集合的笛卡尔积。

并且，从以上结果我们可以看出：

- 两个集合相乘，不满足交换率，即 A×B≠B×A。
- A 集合和 B 集合的笛卡尔积是 A 集合的元素个数 × B 集合的元素个数。

<font color="#900">在数据库中，两表的笛卡尔积就是两个表的所有字段的乘积，在数据较多的时候这会是一个很大的量，所以一般不建议使用交叉查询。</font>

****

##### 内连接（INNER JOIN）

内连接（INNER JOIN）主要通过设置连接条件的方式，来移除查询结果中某些数据行的交叉连接。简单来说就是利用条件表达式来消除交叉连接的某些数据行。

*内连接的语法格式如下：*

**SELECT <字段名> FROM <表1> INNER JOIN <表2> [ON子句]**

*语法说明如下：*

- 字段名：需要查询的字段名称。
- <表1><表2>：需要内连接的表名。
- INNER JOIN ：内连接中可以省略 INNER 关键字，只用关键字 JOIN。
- ON 子句：用来设置内连接的连接条件。

<font color="#900">INNER JOIN 也可以使用 WHERE 子句指定连接条件，但是 INNER JOIN ... ON 语法是官方的标准写法，而且 WHERE 子句在某些时候会影响查询的性能。</font>

****

##### 外连接

内连接的查询结果都是符合连接条件的记录，而外连接会先将连接的表分为基表和参考表，再以基表为依据返回满足和不满足条件的记录。

外连接可以为分为左外连接和右外连接。

###### 左连接

左外连接又称为左连接，使用 **LEFT OUTER JOIN** 关键字连接两个表，并使用 ON 子句来设置连接条件。

*左连接的语法格式如下：*

**SELECT <字段名> FROM <表1> LEFT OUTER JOIN <表2> <ON子句>**

*语法说明如下:*

- 字段名：需要查询的字段名称。
- <表1><表2>：需要左连接的表名。
- LEFT OUTER JOIN：左连接中可以省略 OUTER 关键字，只使用关键字 LEFT JOIN。
- <font color="#900">ON 子句：用来设置左连接的连接条件，不能省略</font>

上述语法中，“表1”为基表，“表2”为参考表。左连接查询时，可以查询出“表1”中的所有记录和“表2”中匹配连接条件的记录。如果“表1”的某行在“表2”中没有匹配行，那么在返回结果中，“表2”的字段值均为空值（NULL）。

```MySQL
mysql> select * from t2;
+----+---------+-----------+
| id | address | id_number |
+----+---------+-----------+
|  1 | 陕西    | 123123123 |
|  2 | 江西    | 123123123 |
|  3 | 云南    | 123123123 |
+----+---------+-----------+
mysql> select * from t1;
+----+-------+------+
| id | name  | age  |
+----+-------+------+
|  1 | li    |   18 |
|  2 | zhang |   18 |
|  3 | wang  |   18 |
|  4 | guo   |   19 |
+----+-------+------+
4 rows in set (0.00 sec)
mysql> select t1.id,t1.name,t2.address from t1 left outer join t2 on t1.id=t2.id;
+----+-------+---------+
| id | name  | address |
+----+-------+---------+
|  1 | li    | 陕西    |
|  2 | zhang | 江西    |
|  3 | wang  | 云南    |
|  4 | guo   | NULL    |
+----+-------+---------+
4 rows in set (0.00 sec)
```

<font color="#900">**这里有两个表t1,t2使用左外连接之后可以看见参考表中没有id为4的数据，所以在address字段就会有出现空值。**</font>



****

###### 右连接

右外连接又称为右连接，右连接是左连接的反向连接。使用 **RIGHT OUTER JOIN** 关键字连接两个表，并使用 ON 子句来设置连接条件。

*右连接的语法格式如下：*

**SELECT <字段名> FROM <表1> RIGHT OUTER JOIN <表2> <ON子句>**

语法说明如下。

- 字段名：需要查询的字段名称。
- <表1><表2>：需要右连接的表名。
- RIGHT OUTER JOIN：右连接中可以省略 OUTER 关键字，只使用关键字 RIGHT JOIN。
- <font color="#900">ON 子句：用来设置右连接的连接条件，不能省略。</font>

与左连接相反，右连接以“表2”为基表，“表1”为参考表。右连接查询时，可以查询出“表2”中的所有记录和“表1”中匹配连接条件的记录。如果“表2”的某行在“表1”中没有匹配行，那么在返回结果中，“表1”的字段值均为空值（NULL）。

```MySQL
mysql> select * from t2;
+----+---------+-----------+
| id | address | id_number |
+----+---------+-----------+
|  1 | 陕西    | 123123123 |
|  2 | 江西    | 123123123 |
|  3 | 云南    | 123123123 |
|  4 | 香港    | 326146    |
|  5 | 台湾    | 326146    |
+----+---------+-----------+
5 rows in set (0.00 sec)
mysql> select * from t1;
+----+-------+------+
| id | name  | age  |
+----+-------+------+
|  1 | li    |   18 |
|  2 | zhang |   18 |
|  3 | wang  |   18 |
|  4 | guo   |   19 |
+----+-------+------+
mysql> select t1.id,t1.name,t2.address from t1 right outer join t2 on t1.id=t2.id;
+------+-------+---------+
| id   | name  | address |
+------+-------+---------+
|    1 | li    | 陕西    |
|    2 | zhang | 江西    |
|    3 | wang  | 云南    |
|    4 | guo   | 香港    |
| NULL | NULL  | 台湾    |
+------+-------+---------+
5 rows in set (0.00 sec)
```

<font color="#900">**这里有两个表t1,t2使用右外连接之后可以看见参考表中没有id为5的数据，所以在id和name字段就会有出现空值。**</font>





****

#### 子查询(内部查询)





****

## 模糊查詢（LIKE）

在日常使用和工作业务中，我们可能会经常使用模糊查询来通过某个字段和条件来进行信息的查找。

**语法结构：**

**SELECT * FROM < tablename > WHERE name LIKE "%value%"**

LIKE的用法可以理解为代替了=而存在，我们使用LIKE关键字的时候还需要配合通配符来使用。

| 通配符                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 百分号（%）               | 代表零或多个任意的字符。                                     |
| 下划线（_）               | 代表单个字符或数字                                           |
| [charlist]                | 字符列表中的任何单一字符。可以使用连字符（-）根据 ASCII 编码指定一个字符范围，例如 :[0-9] 表示从 0 到 9 的任一数字； [a-z] 表示小写英文字母； [a-zA-Z] 表示英文字母，不区分大小写； [a-zA-Z0-9] 表示英文字母和阿拉伯数字。 |
| [^charlist] 或[!charlist] | 不在字符列表中的任何单一字符。同上，也可以使用连字符（-）指定一个字符范围。 |

**实际代码：**

```mysql
mysql> select * from mb;
+----+--------+
| id | name   |
+----+--------+
|  1 | lzy    |
|  2 | 王     |
|  4 | 张三   |
|  5 | 张三   |
|  7 | wang   |
|  9 | zhang  |
| 10 | zhang  |
| 11 | zhang  |
+----+--------+
8 rows in set (0.01 sec)
mysql> SELECT * FROM mb WHERE name LIKE "%z%";
+----+-------+
| id | name  |
+----+-------+
|  1 | lzy   |
|  9 | zhang |
| 10 | zhang |
| 11 | zhang |
+----+-------+
4 rows in set (0.00 sec)
```

这里可以看到我们查找了姓名字段中带有z字符的所有用户信息。



## 查询数据分页操作

在真正的项目中，我们查询数据不可能每次都是将所有的数据查询出来，而是之只查询除一部分，当有需要的时候在进行其余数据的查询。

**关键字**

<font color="#F00">**LIMIT**</font>

**语法结构：**

**`SELECT * FROM tablename WHERE conlumn=condition LIMIT last,number;`**

- **last：**

  返回查询出所有内容的结果集，从中指定的第一个位置的信息，下标从0开始。

- **number：**

  最终返回结果集的总字段信息条数。

**实际代码演示**

```mysql
mysql> select * from t
    -> ;
+----+------+-----+
| id | name | age |
+----+------+-----+
|  1 | li1  |  18 |
|  2 | li2  |  18 |
|  3 | li3  |  18 |
|  4 | li4  |  18 |
|  5 | li5  |  18 |
|  6 | li6  |  18 |
|  7 | li7  |  18 |
|  8 | li8  |  18 |
|  9 | li9  |  18 |
| 10 | li10 |  18 |
| 11 | li11 |  18 |
| 12 | li12 |  18 |
| 13 | li13 |  18 |
| 14 | li14 |  18 |
| 15 | li15 |  18 |
| 16 | li16 |  18 |
| 17 | li17 |  18 |
| 18 | li18 |  18 |
| 19 | li19 |  18 |
+----+------+-----+
mysql> SELECT * FROM t WHERE age=18 LIMIT 9,8;
+----+------+-----+
| id | name | age |
+----+------+-----+
| 10 | li10 |  18 |
| 11 | li11 |  18 |
| 12 | li12 |  18 |
| 13 | li13 |  18 |
| 14 | li14 |  18 |
| 15 | li15 |  18 |
| 16 | li16 |  18 |
| 17 | li17 |  18 |
+----+------+-----+
8 rows in set (0.00 sec)
```

**LIMIT**高效率的原理是：避免全表扫描，提高查询效率。

## 数据库设计

### E-R模型

**E-R模型也叫做实体关系图，是描述实体和实体关系的图，是uml图的一种。**

我们在画E-R模型的时候，方块代表实体，就是一个一个的表，椭圆代表着属性，在数据库中就是字段，菱形代表着表和表之间的关系。

在数据库中，表和表之间都有三种关系，一种是一对一关系(1:1)，一对多关系(1:n)，多对多关系(n:m)。

- 一对一关系：在数据库中如果两个表之间是一对一关系的话，他们两个之间是没有关系的。**一对一关系就像是学校和校长之间的关系，一个学校只能有一个校长，一个校长只能管理一个学校。**
- 一对多关系：在数据库中如果又两个表之间是一对多关系，那么就代表两个表中一个表的主键是另外一个表的外键，拥有外键的表就是多的那个表。**一对多关系就像是学生和教室之间的关系，一个教室里可以有很多学生，但是一个学生只能有一个教室。**
- 多对多关系：在数据库中两个表之间如果是多对多关系，这个时候需要新建一个表，分别以一对多的形式链接两个表。**多对多关系就像是学生和选修课程之间的关系，一个学生可以选修多门可课程，一个课程也可以有多个学生选修。**

****

### 范式

**数据库目前又六种范式，范式可以提高数据库的合理性：第一范式(1NF),第二范式(2NF),第三范式(3NF)，巴斯-科德范式(BCNF)，第四范式(4NF)，第五范式(5NF)完美范式。在我们的日常使用中，只要达到三范式的标准就已经绰绰有余了。**

- **第一范式：**第一范式的定义是属性要具有原子性。

  意思就是所有字段中的数据项不可以在进行分解。简单的说就是每个字段中的数据内容都是单独的一个数据，不存在多种数据拼接的情况，例如地址，地址就不具备原子性，它可以分为城市省区四个字段。

- **第二范式：**在第一范式的基础上，第二范式的定义是实体属性完全依赖主关键字。

  意思是在一个表中，表中字段完全依赖表名存在，例如笔记本电脑表中包含cpu很合理，但是包含鼠标就会存在问题了，简单来说就是每个表只做一件事情。

- **第三范式：**在符合第二范式的基础上，消除传递依赖。

  意思就是每张表中的除主键以外的其他字段属性，不对非主键字段属性产生依赖，且要求数据库表中不包含已在其它表中 包含的非主关键字信息。例如笔记本电脑的型号，cup，核显在一个表中，这个时候核显依赖cpu存在，cpu依赖电脑型号存在，这个时候就不符合第三范式。应该单独列出一个主键为电脑型号，字段为核显的表。这样在修改和添加表的时候可以有效的减少修改和删除异常。



## MySql常用函数



## 错误问题以及解决方式

### navicat15中文乱码：

**首先排除掉是数据库和Java程序中的问题，确定是navicat存在问题。**

这里只需要将数据库连接的编码格式设置为自动就可以解决中文乱码的问题了。

![image-20220328110005907](C:\Users\SaoLinSiDaShiXiong\AppData\Roaming\Typora\typora-user-images\image-20220328110005907.png)

![image-20220328110030334](C:\Users\SaoLinSiDaShiXiong\AppData\Roaming\Typora\typora-user-images\image-20220328110030334.png)



****

### Before start of result set报错：

这里是因为没有添加**rs.next()**方法。

**因为ResultSet是一个结果集，想要读出来必须使用next方法进行读取。**
