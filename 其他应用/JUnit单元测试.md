# JUnit单元测试

**单元测试（junit testing）**，是指对软件中的最小可测试单元进行检查和验证。

**JUnit是一个开源的Java单元的是框架，是Java的标准的单元测试库，是非常重要的第三方Java库，由Kent Beck 和 Erich Gamma 开发。**

### 什么是单元测试？

单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。比如我们可以测试一个类，或者一个类中的一个方法。

****

### 为什么要进行单元测试？

为什么要进行单元测试？说白了就是单元测试有什么好处，其实测试的好处无非就是减少bug、提高代码质量、使代码易于维护等。单元测试有什么好处请看一下百度百科中归纳的四条：



1、它是一种验证行为。
程序中的每一项功能都是测试来验证它的正确性。它为以后的开发提供支援。就算是开发后期，我们也可以轻松的增加功能或更改程序结构，而不用担心这个过程中会破坏重要的东西。而且它为代码的重构提供了保障。这样，我们就可以更自由的对程序进行改进。


2、它是一种设计行为。
编写单元测试将使我们从调用者观察、思考。特别是先写测试（test-first），迫使我们把程序设计成易于调用和可测试的，即迫使我们解除软件中的耦合。


3、它是一种编写文档的行为。
单元测试是一种无价的文档，它是展示函数或类如何使用的最佳文档。这份文档是可编译、可运行的，并且它保持最新，永远与代码同步。

4、它具有回归性。
自动化的单元测试避免了代码出现回归，编写完成之后，可以随时随地的快速运行测试。

### JUnti单元测试和使用main方法进行测试的区别

**首先这里要说的是，使用JUnti进行单元测试，不能说明你是对的，只能说明你没有错。即可以测试出代码中没有bug，但不能测试出代码中是否有逻辑性的问题。**

1. JUnti测试的结果更加直观，可以直接根据状态条的颜色即可判断测试是否通过，而用main方法你需要去检查他的输出结果，然后跟自己的期望结果进行对比，才能知道是否测试通过。有一句话能够很直观的说明这一点——keeps the bar green to keeps the code clean。意思就是说，只要状态条是绿色的，那么你的代码就是正确的。
2. JUnit让我们同时运行多个测试变得非常简单方便。
   

## JUnit单元测试步骤：

1. 导入包junit测试包:JUnit测试版本，3.81版，4.0版，导入对应的jar包；（在eclipse中有相应的支持，可以不用导入jar包，直接可以应用）

2. 写一个类扩展（继承）TestCase；<font color="#f00">也可以通过引入该类来调用该类的方法</font>

   ```Java
   import org.junit.Test;
   ```

3. 在需要测试的方法名前加test生成新的测试方法；

4. 运行测试，用断言（assert***）的方法测试成功（显示绿色）或失败（显示红色），或者自己判断结果正确与否。

## Unit3.81与JUnit4.0区别：

1. 在 JUnit 4 中，测试是由 @Test 注释来识别的；
2. Unit 3.81 测试运行程序时会在运行每个测试之前自动调用 setUp() 方法，在JUnit4.0中，要用 @Before 注释；
3. 在 JUnit 3.81 中，测试运行程序时会在运行每个测试之前自动使用 tearDown() 方法清除消耗的资源，在JUnit4.0中，用 @After 注释。

注意：如果需测试的方法没有返回值，只能测试其过程。

## JUnit4新特性:

1. 属于类范围的 setUp()方法 和 tearDown() 方法,任何用 @BeforeClass 注释的方法都将在该类中的测试方法运行之前运行一次，而任何用 @AfterClass 注释的方法都将在该类中的所有测试都运行之后运行一次；

2. 异常测试：编写抛出异常的代码，并使用注释来声明该异常是预期的；

3. 在需要高效率的测试中，有些代码测试你认为可以跳过，这类测试可以被注释为 @Ignore

4. 时间测试可以用超时参数来注释，如果测试的运行时间超过指定的毫秒数，测试失败。 

5. 增加两个新的断言方法:

   (1)

   ```Java
   public static void assertEquals(Object[] expected, Object[] actual)
   ```


   (2)

   ```java
   public static void assertEquals(String message, Object[] expected, Object[] actual) 
   ```

   这两个方法用来比较数组：如果数组长度相等且对应的元素相同，则这两个数组相等，否则不等，也考虑了数组为空的情况。

## JUnit常用注解

首先以Junit4为基础介绍常用注解：
常用的JUnit注解包括@BeforeClass、@AfterClass、@Before、@After、@Test、@Ignore等。
它们得到了每个测试用例的运行次序，即：**@BeforeClass–>@Before–>@Test–>@After–>@AfterClass**，从而确定了整个测试流程。

| 注解         | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| @BeforeClass | 所注解的方法是JUnit测试时首先被运行的方法且只能运行一次，通常用来进行预处理等操作。 |
| @Before      | 所注解的方法在每个Test测试用例运行前运行，常用来进行初始化测试用例所需的资源。 |
| @Test        | 所注解方法的代码为测试用例，包含对源程序的测试代码。包括expected和timeout两个可选参数。其中：expected表示测试用例运行后应该抛出的异常；timeout表示测试方法的运行时间，以避免程序测试时死循环或测试时间过长。 |
| @After       | 所注解的方法在每个Test测试用例运行后运行，常用于释放@Before注解方法打开的资源。(当@Before或@Test注解的方法发生异常时，@After所注解的方法仍会被运行) |
| @AfterClass  | 所注解的方法是JUnit测试时最后一个被运行的方法且只能运行一次，通常用来释放相关使用资源。 |
| @Ignore      | 所注解的方法在测试过程中不会运行。                           |

## JUnit5常用注解

**JUnit5和JUint4的注解有些不相同的地方，有些注解的名字和作用都有很大的区别。**

| 注解               | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| @Test              | 表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试 |
| @ParameterizedTest | 表示方法是参数化测试                                         |
| @RepeatedTest()    | 表示方法可重复执行，传入一个int类型的参数，标识该测试执行的次数。 |
| @DisplayName()     | 为测试类或者测试方法设置展示名称，传入测试方法的名字。       |
| @BeforeEach        | 表示在每个单元测试之前执行                                   |
| @AfterEach         | 表示在每个单元测试之后执行                                   |
| @BeforeAll         | 表示在所有单元测试之前执行                                   |
| @AfterAll          | 表示在所有单元测试之后执行                                   |
| @Tag               | 表示单元测试类别，类似于JUnit4中的@Categories                |
| @Disabled          | 表示测试类或测试方法不执行，类似于JUnit4中的@Ignore          |
| @Timeout()         | 表示测试方法运行如果超过了指定时间将会返回错误               |
| @ExtendWith        | 为测试类或测试方法提供扩展类引用                             |

