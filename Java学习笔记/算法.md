# 算法

## 时间复杂度

“O”是时间复杂度的表示，时间复杂度越低，程序运行的就越快。

| 算法名称              | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性 |
| :-------------------- | :----------------: | :----------------: | :----------------: | :--------: | ------ |
| 冒泡算法              |       O(N²)        |       O(N²)        |       O(N²)        |    O(1)    | 稳定   |
| 冒泡排序（外层优化）  |       O(N²)        |       O(N²)        |        O(N)        |    O(1)    | 稳定   |
| 冒泡排序（外+内优化） |       O(N²)        |       O(N²)        |        O(N)        |    O(1)    | 稳定   |
| 快速排序（经典）      |     O(N log N)     |       O(N²)        |     O(N log N)     | O(N log N) | 不稳定 |
| 快速排序（随机）      |     O(N log N)     |     O(N log N)     |     O(N log N)     | O(N log N) | 不稳定 |
| 插入排序              |       O(N²)        |       O(N²)        |        O(N)        |    O(1)    | 稳定   |
| 希尔排序              |     O(N log N)     |    O(N log² N)     |    O(N log² N)     |    O(1)    | 不稳定 |
| 选择排序              |       O(N²)        |       O(N²)        |       O(N²)        |    O(1)    | 稳定   |
| 堆排序                |     O(N log N)     |     O(N log N)     |     O(N log N)     |    O(1)    | 不稳定 |
| 二路并归排序          |     O(N log N)     |     O(N log N)     |     O(N log N)     |    O(N)    | 稳定   |
| 多路路归并排序        |     O(N log N)     |     O(N log N)     |     O(N log N)     |    O(N)    | 稳定   |
| 计数排序              |      O(N + k)      |      O(N + k)      |      O(N + k)      |  O(N + k)  | 稳定   |
| 桶排序                |      O(N + k)      |       O(N²)        |      O(N + k)      |  O(N + k)  | 稳定   |
| 基数排序              |      O(N * k)      |      O(N * k)      |      O(N * k)      |  O(N + k)  | 稳定   |



## 排序算法

排序可以对对象进行排序（通过关键字），也可以对数据进行排序。

### 冒泡排序

**冒泡排序是最出名的排序算法之一，它的过程就是从序列的一段从另一端冒泡，依次比较相邻两个数的大小。**

#### 排序过程

**从一个方向向另外一个方向进行依次比较，按照规律进行排序，从右向左将最大的数放在最右边，即如果左边的数比右边的数大就进行位置的调换，接着比较下面的两个数以此类推将每个数都比较一遍。需要注意的是比较交换的顺序决定了大小排列的顺序**

#### Java代码

```java
public static void main(String args[]){
    int[] array = new int[]{2,4,6,1,3,7,9,0,8};
    for(int i= 0;i < array.length;i++){
        for(int j = 0;j < array.length;j++){
            int temp = 0;
            if(array[i] < array[j+1]){
                temp = array[j];
                array[j] = array[i];
                array[i] = temp;
            }
        }
    }
}
```

#### 要点注意

##### 数据的交换

因为在代码中我们直接进行数据的交换第一个数据就会被覆盖。所以想要进行数据的交换，我们需要一个临时变量来进行变量的储存，将变量a放到临时变量c中，再将变量b中的数据放到变量a中，最后把临时变量中的a的数据放到变量b中。

### 插入排序

**插入排序是最接近我们思维的一种排序，它是将一组数据中最小的拿出来，插入到第一个的位置。**

#### 排序过程

插入排序的排序过程是这样的，首先将数据中最小的数据找出来，把他和第一个数据进行交换，然后在剩下的数据中继续找出最小的数据，将他放到第二位的数据进行交换，以此类推直至所有的数据都进行过此次操作。只要是通过这种手段进行排序的，都叫插入排序。

#### Java代码

```java
public static void main(String args[]){
    int[] array = {2,4,6,1,3,7,9,0,8};
    for(int i = 1;i < array.length;i++){
        int position = i;
        int value = array[i];
        while(position > 0 && array[position - 1] > value){
            array[position] = array[position - 1];
            position--;
        }
        if(position != i){
            array[position] =  value;
        }
    }
}
```

```java
public static  void main(String args[]){
    int[] array = {2,4,6,1,3,7,9,0,8};
    for(int i = 1;i < array.length;i++){
        int value = array[i];
        int position = i - 1;
        for(;position >= 0;position--){
            if(array[position] < value){
               array[position + 1] = array[position];
            }else{
                break;
            }
        }
        array[position + 1] = value;
    }
}
```





#### 要点注意

插入排序比较的数据可能会比较少，单移动的数据量可能会很多。在使用排序算法进行数据排序的时候需要注意它的运行方式跟我们生活中所想的不一样。常用的做法是找到数据堆中的第二个数据拿出来与前面的数据比较，按照规定的大小排列，然后找到第三个数据，向前依次比较，按照规定的大小数据排列......直到比较到最后一个数。

**需要注意的是：在进行代码编辑的过程中，我们需要声明两个第三方变量，一个用来定位数据位置，一个用来存储我们要插入的数据。通过这个位置来定位数据，进行和需要插入的原有数据比较，比较完成之后，最后一步再将原有数据放到符合排列条件的位置，最后一步就是插入数据的操作。**

**在使用for循环的时候需要注意for循环的运行结构，for在运行的过程中即使条件表达式的结果为false，for循环中的迭代语句也会执行。**

### 选择排序

#### 排序过程

找到最小的值，拿出来放到第一个的位置，然后在剩下的值中找到最小的数，放到第二个的位置，以此类推完成排序（这种方法找出的是从小到大的排序）

**在未排序序列中找到最大（小）的元素，存放到排序序列中的起始位置，**

## 递归算法

## 分治算法

**分治算法是一种很重要的算法（分而治之）当我们去处理一个复杂问题，而这个给问题无法直接给出结果。就可使用分治算法，分治算法是很多高效算法的基础**

分治算法可以将复杂问题分为多个相同或相似的子问题，也可以继续将子问题拆分为多个相似或相同的子问题...直到最后子问题可以简单的求解为止。原问题的答案就是这些子问题的合并。

### 分治法的基本思想

**将一个难以直接解决得大问题分割成一些规模比较小的相同问题，以便各个击破，分而治之。子问题的和可以成为主问题的解**

### 使用分治算法求解的一些问题：

#### 1.二分查找

问题：从1000人中查找

答： 先分500进行查找，如果找不到，就将剩下的500人在分为一半也就是250进行查找...

#### 2.循环赛日程表

#### 3.汉诺塔

### 回溯算法

**将问题的解空间转化成了图或树的结构表示**
